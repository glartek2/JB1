[
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\nde",
        "middle": "def main():\n\n    W, H, S = map(int, sys.stdin.readline().split())\n\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]",
        "suffix": "\n    start_x = start_y = -1\n    for i in range(H):\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\noccu",
        "middle": "occupied.add((nx, ny))\n\n        path += direction.name\n\n        x, y = nx, ny",
        "suffix": "\n    return x, y, collected, path, occupied\n\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\n    W, H, S = map(int, sys.stdin.readline().split())\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    start_x = start_y = -1\n    for i in range(H):\n        for j in range(W):\n            if board[i][j] == 'O':\n                start_x, start_y = i, j\n                break\nif s",
        "middle": "if start_x != -1:\n\n            break",
        "suffix": "\n    result = solve(board, S, start_x, start_y)\n    print(result)\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\npa",
        "middle": "path = \"\"\n\n    collected = 0",
        "suffix": "\n    while True:\n        nx, ny = x + dx, y + dy\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef ",
        "middle": "def main():\n\n    W, H, S = map(int, sys.stdin.readline().split())\n\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]",
        "suffix": "\n    start_x = start_y = -1\n    for i in range(H):\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\nwhil",
        "middle": "while True:\n\n        nx, ny = x + dx, y + dy",
        "suffix": "        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\nretu",
        "middle": "return x, y, collected, path, occupied",
        "suffix": "def solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\npa",
        "middle": "path = \"\"\n\n    collected = 0",
        "suffix": "    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\ni",
        "middle": "if eaten >= S:\n\n            return path",
        "suffix": "\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\n    W, H, S = map(int, sys.stdin.readline().split())\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    start_x = start_y = -1\n    for i in range(H):\nfo",
        "middle": "for j in range(W):\n\n            if board[i][j] == 'O':",
        "suffix": "                start_x, start_y = i, j\n                break\n        if start_x != -1:\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\nW, ",
        "middle": "W, H, S = map(int, sys.stdin.readline().split())\n\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]",
        "suffix": "\n    start_x = start_y = -1\n    for i in range(H):\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\nvis",
        "middle": "visited.add(state)",
        "suffix": "        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\n    W, H, S = map(int, sys.stdin.readline().split())\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    start_x = start_y = -1\n    for i in range(H):\n        for j in range(W):\n            if board[i][j] == 'O':\n                start_x, start_y = i, j\n                break\n        if start_x != -1:\n            break\n\n    result = solve(board, S, start_x, start_y)\nprin",
        "middle": "print(result)",
        "suffix": "\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\n    W, H, S = map(int, sys.stdin.readline().split())\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    start_x = start_y = -1\n    for i in range(H):\n        for j in range(W):\n            if board[i][j] == 'O':\nsta",
        "middle": "start_x, start_y = i, j\n\n                break",
        "suffix": "        if start_x != -1:\n            break\n\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\nc",
        "middle": "collected += 1\n\n\n\n        occupied.add((nx, ny))",
        "suffix": "        path += direction.name\n        x, y = nx, ny\n\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nc",
        "middle": "class Direction(Enum):\n\n    P = (0, 1)\n\n    G = (-1, 0)",
        "suffix": "    L = (0, -1)\n    D = (1, 0)\n\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\nco",
        "middle": "collected += 1\n\n\n\n        occupied.add((nx, ny))",
        "suffix": "        path += direction.name\n        x, y = nx, ny\n\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\nfor",
        "middle": "for direction in Direction:\n\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)",
        "suffix": "            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\nif b",
        "middle": "if board[nx][ny] == '#' or (nx, ny) in occupied:\n\n            break\n\n        if board[nx][ny] == '*':",
        "suffix": "            collected += 1\n\n        occupied.add((nx, ny))\n"
    },
    {
        "prefix": "import sys\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    P = (0, 1)\n    G = (-1, 0)\n    L = (0, -1)\n    D = (1, 0)\n\n\ndef move(board, occupied, x, y, direction):\n    dx, dy = direction.value\n    path = \"\"\n    collected = 0\n\n    while True:\n        nx, ny = x + dx, y + dy\n        if board[nx][ny] == '#' or (nx, ny) in occupied:\n            break\n        if board[nx][ny] == '*':\n            collected += 1\n\n        occupied.add((nx, ny))\n        path += direction.name\n        x, y = nx, ny\n\n    return x, y, collected, path, occupied\n\n\ndef solve(board, S, start_x, start_y):\n    queue = deque([(start_x, start_y, 0, \"\", {(start_x, start_y)})])\n    visited = set()\n\n    while queue:\n        x, y, eaten, path, occupied = queue.popleft()\n\n        if eaten >= S:\n            return path\n\n        state = (x, y, eaten, tuple(sorted(occupied)))\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for direction in Direction:\n            nx, ny, new_eaten, new_path, new_occupied = move(board, occupied.copy(), x, y, direction)\n            queue.append((nx, ny, eaten + new_eaten, path + new_path, new_occupied))\n\n    return None\n\n\ndef main():\n    W, H, S = map(int, sys.stdin.readline().split())\n    board = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    start_x = start_y = -1\n    for i in range(H):\n        for j in range(W):\n            if board[i][j] == 'O':\n                start_x, start_y = i, j\n                break\n        if start_x != -1:\n            break\n\nre",
        "middle": "result = solve(board, S, start_x, start_y)\n\n    print(result)",
        "suffix": "\nif __name__ == \"__main__\":\n    main()"
    }
]